# 📋 호텔 예약 시스템 시나리오 및 예약/룸 로직

## 사용자 예약 시나리오

### 시나리오 1: 정상 예약 프로세스

```
1. 사용자 로그인
   → JWT 토큰 발급 및 저장

2. 객실 조회
   → /rooms 페이지 접속
   → 체크인/체크아웃 날짜 선택
   → 예약 가능한 객실 목록 조회

3. 객실 선택
   → 객실 상세 정보 확인
   → 리뷰 및 평점 확인
   → 예약하기 버튼 클릭

4. 예약 정보 입력
   → /booking?roomId=1&checkIn=2025-01-15&checkOut=2025-01-17
   → 인원수 선택
   → 특별 요청사항 입력 (선택)
   → 총 금액 확인

5. 결제 방법 선택
   → 카드 / 계좌이체 / 현금 선택

6. 예약 생성
   → POST /api/bookings
   → 중복 예약 체크 수행
   → 예약 생성 (status = CONFIRMED)
   → 결제 처리 (status = PAID)

7. 예약 확인
   → 마이페이지에서 예약 내역 확인
   → 예약 상세 정보 확인
```

---

### 시나리오 2: 중복 예약 방지

```
사용자 A: Room 101, 2025-01-15 ~ 2025-01-17 예약 시도
  → 예약 생성 성공
  → Booking.status = CONFIRMED

사용자 B: Room 101, 2025-01-16 ~ 2025-01-18 예약 시도
  → 중복 체크 수행
  → 날짜 범위 겹침 확인
  → 예약 생성 실패
  → 에러 메시지: "선택한 날짜에 이미 예약이 있습니다."
```

**중복 체크 로직**:
```java
// 날짜 범위 겹침 조건
(checkInDate_A < checkOutDate_B) AND (checkOutDate_B > checkInDate_A)

// 예시
예약 A: 2025-01-15 ~ 2025-01-17
예약 B: 2025-01-16 ~ 2025-01-18
→ (2025-01-15 < 2025-01-18) AND (2025-01-18 > 2025-01-15) = TRUE
→ 중복 예약 불가
```

---

### 시나리오 3: 예약 취소

```
1. 사용자가 예약 취소 요청
   → 마이페이지 → 예약 내역
   → 취소 가능한 예약 확인 (status = CONFIRMED)

2. 예약 취소 처리
   → DELETE /api/bookings/{id}
   → Booking.status = CANCELLED
   → 결제 내역은 보존 (법적 증빙 자료)

3. 취소된 예약은 다시 예약 가능
   → 같은 날짜에 새 예약 생성 가능
```

**⚠️ 주의**: `CHECKED_IN` 상태에서는 취소 불가

---

## 관리자 체크인/체크아웃 시나리오

### 시나리오 4: 체크인 처리

```
1. 관리자 대시보드 접속
   → 오늘 체크인 목록 확인
   → 예약 ID, 객실명, 고객명 표시

2. 체크인 처리
   → 체크인 버튼 클릭
   → PUT /api/admin/bookings/{id}/status
   → Booking.status = CHECKED_IN
   → Room.status = CLEAN (변경 없음)

3. 대시보드 업데이트
   → "오늘 체크인" 목록에서 제거
   → "현재 투숙 중" 목록에 추가
```

---

### 시나리오 5: 체크아웃 처리

```
1. 관리자 대시보드 접속
   → 오늘 체크아웃 목록 확인
   → 예약 ID, 객실명, 고객명 표시

2. 체크아웃 처리
   → 체크아웃 버튼 클릭
   → PUT /api/admin/bookings/{id}/status
   → Booking.status = CHECKED_OUT
   → Room.status = DIRTY (자동 변경) ⚡
   → Room.statusUpdatedAt = 현재 시간

3. 대시보드 업데이트
   → "오늘 체크아웃" 목록에서 제거
   → "청소 필요" 카운트 증가
```

**자동화 로직**:
```java
if (status == BookingStatus.CHECKED_OUT) {
    Room room = booking.getRoom();
    room.setStatus(RoomStatus.DIRTY);
    room.setStatusUpdatedAt(LocalDateTime.now());
    roomRepository.save(room);
}
```

---

### 시나리오 6: 청소 완료 처리

```
1. 청소 작업 완료
   → 객실 청소 완료

2. 관리자가 청소 완료 처리
   → 관리자 대시보드 → 객실 관리
   → 청소 필요 상태인 객실 선택
   → 상태 변경: DIRTY → CLEAN
   → PUT /api/admin/rooms/{id}/status

3. 객실 상태 업데이트
   → Room.status = CLEAN
   → Room.statusUpdatedAt = 현재 시간
   → "청소 완료 객실" 카운트 증가
```

---

## 객실 상태 관리 시나리오

### 시나리오 7: 보수 작업

```
1. 관리자가 보수 시작
   → 객실 관리 → 상태 변경
   → Room.status = MAINTENANCE
   → Room.available = false (선택사항)

2. 보수 작업 진행
   → 객실 사용 불가
   → 예약 불가 (available = false 또는 status = MAINTENANCE)

3. 보수 완료
   → 관리자가 상태 변경
   → Room.status = CLEAN
   → Room.available = true
   → 예약 가능 상태로 복귀
```

---

### 시나리오 8: 객실 비활성화

```
1. 장기 리모델링 계획
   → 관리자가 객실 비활성화
   → Room.available = false
   → Room.status = CLEAN (또는 다른 상태, 독립적)

2. 예약 불가 상태
   → available = false이므로 예약 생성 시 차단
   → 기존 예약은 유지 (과거 예약 보존)

3. 리모델링 완료 후 재활성화
   → Room.available = true
   → Room.status = CLEAN
   → 예약 가능 상태로 복귀
```

---

## 예약 가능 여부 판단 로직

### 객실 예약 가능 조건

```java
// 1. 객실 활성화 여부
if (!room.getAvailable()) {
    return false; // 비활성화된 객실
}

// 2. 날짜 범위에 취소되지 않은 예약이 있는지 확인
List<Booking> overlappingBookings = 
    bookingRepository.findByRoomAndCheckInDateAndCheckOutDate(
        room, checkInDate, checkOutDate);

boolean hasOverlap = overlappingBookings.stream()
    .anyMatch(b -> b.getStatus() != BookingStatus.CANCELLED);

if (hasOverlap) {
    return false; // 중복 예약 존재
}

// 3. 체크인 날짜가 오늘 이후인지 확인
if (checkInDate.isBefore(LocalDate.now())) {
    return false; // 과거 날짜 예약 불가
}

return true; // 예약 가능
```

**⚠️ 중요**: `Room.status`는 예약 가능 여부에 직접 영향을 주지 않습니다.
- `status = DIRTY`여도 예약 가능 (청소는 나중에 처리)
- `status = MAINTENANCE`여도 예약 가능 (단, 관리자가 수동으로 체크 가능)

---

## 대시보드 통계 계산 시나리오

### 예약 기준 통계

```java
// 1. 예약 (booked)
// 조건: CONFIRMED + 체크인 날짜 >= 오늘
long booked = bookings.stream()
    .filter(b -> b.getStatus() == BookingStatus.CONFIRMED)
    .filter(b -> !b.getCheckInDate().isBefore(LocalDate.now()))
    .count();

// 2. 오늘 체크인
// 조건: CONFIRMED + 체크인 날짜 = 오늘
long todayCheckIns = bookings.stream()
    .filter(b -> b.getStatus() == BookingStatus.CONFIRMED)
    .filter(b -> b.getCheckInDate().equals(LocalDate.now()))
    .count();

// 3. 현재 투숙 중
// 조건: CHECKED_IN
long currentStays = bookings.stream()
    .filter(b -> b.getStatus() == BookingStatus.CHECKED_IN)
    .count();

// 4. 오늘 체크아웃
// 조건: CHECKED_IN + 체크아웃 날짜 = 오늘
long todayCheckOuts = bookings.stream()
    .filter(b -> b.getStatus() == BookingStatus.CHECKED_IN)
    .filter(b -> b.getCheckOutDate().equals(LocalDate.now()))
    .count();
```

### 객실 기준 통계

```java
// 1. 청소 완료 객실
// 조건: status = CLEAN
long available = rooms.stream()
    .filter(r -> r.getStatus() == RoomStatus.CLEAN)
    .count();

// 2. 청소 필요
// 조건: status = DIRTY
long cleaningNeeded = rooms.stream()
    .filter(r -> r.getStatus() == RoomStatus.DIRTY)
    .count();

// 3. 보수 중
// 조건: status = MAINTENANCE
long maintenance = rooms.stream()
    .filter(r -> r.getStatus() == RoomStatus.MAINTENANCE)
    .count();
```

**⚠️ 중요**: 예약 기준과 객실 기준은 독립적으로 계산됩니다.

---

## 예외 시나리오

### 시나리오 9: 동시 예약 시도 (Race Condition)

```
사용자 A와 B가 동시에 같은 객실을 예약 시도
  → 둘 다 중복 체크를 통과할 수 있음
  → 트랜잭션 격리 수준 문제

현재 대응:
  - 애플리케이션 레벨 체크만 수행
  - 동시성 문제 완전 방지는 어려움

향후 개선:
  - 비관적 락 (PESSIMISTIC_WRITE) 사용
  - 또는 DB 제약조건 (EXCLUDE) 사용
```

---

### 시나리오 10: 체크아웃 후 즉시 예약

```
1. 체크아웃 처리
   → Room.status = DIRTY
   → Booking.status = CHECKED_OUT

2. 같은 날 새 예약 생성 시도
   → available = true이므로 예약 가능
   → status = DIRTY여도 예약 생성 가능
   → (청소는 나중에 처리)

3. 체크인 전 청소 완료 처리
   → 관리자가 청소 완료 처리
   → Room.status = CLEAN
```

---

## 상태 다이어그램

### 예약 상태 흐름

```
        [예약 생성]
            ↓
      CONFIRMED
         ↙   ↘
   [체크인]  [취소]
       ↓        ↓
  CHECKED_IN  CANCELLED
       ↓
  [체크아웃]
       ↓
  CHECKED_OUT
```

### 객실 상태 흐름

```
      CLEAN
        ↓
   [체크아웃]
        ↓
      DIRTY
        ↓
   [청소 완료]
        ↓
      CLEAN

      CLEAN
        ↓
   [보수 시작]
        ↓
   MAINTENANCE
        ↓
   [보수 완료]
        ↓
      CLEAN
```

---

## API 엔드포인트 요약

### 예약 관련

- `POST /api/bookings` - 예약 생성
- `GET /api/bookings/my` - 내 예약 목록
- `DELETE /api/bookings/{id}` - 예약 취소

### 관리자 예약 관리

- `GET /api/admin/bookings/today-checkins` - 오늘 체크인 목록
- `GET /api/admin/bookings/today-checkouts` - 오늘 체크아웃 목록
- `GET /api/admin/bookings/current-stays` - 현재 투숙 중 목록
- `PUT /api/admin/bookings/{id}/status` - 예약 상태 변경

### 객실 관리

- `GET /api/rooms` - 객실 목록 조회
- `GET /api/rooms/{id}` - 객실 상세 조회
- `PUT /api/admin/rooms/{id}/status` - 객실 상태 변경
- `PUT /api/admin/rooms/{id}/available` - 객실 활성화/비활성화

---

**작성일**: 2025년 1월

